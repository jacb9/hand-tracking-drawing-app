<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hand-Tracking Drawing App</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; }
    canvas { position: absolute; top: 0; left: 0; z-index: 1; }
    video { display: none; }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 10px;
      z-index: 2;
    }
    #controls input, #controls button {
      display: block;
      margin: 6px 0;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="output"></canvas>

  <div id="controls">
    <label for="brushSize">Brush Size</label>
    <input type="range" id="brushSize" min="1" max="20" value="4">
    <button id="saveButton">Save Drawing</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('output');
    const ctx = canvas.getContext('2d');
    const brushSizeInput = document.getElementById('brushSize');
    const saveButton = document.getElementById('saveButton');

    const roygbiv = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#8b00ff'];

    let brushSize = parseInt(brushSizeInput.value);
    let lastPositions = {};
    let colorIndex = {};
    let colorByHand = {};
    let lastPinchTime = {};
    let lastClearTime = 0;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    brushSizeInput.addEventListener('input', () => {
      brushSize = parseInt(brushSizeInput.value);
    });

    saveButton.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'drawing.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    function isPinching(landmarks) {
      const dx = landmarks[8].x - landmarks[4].x;
      const dy = landmarks[8].y - landmarks[4].y;
      return Math.sqrt(dx * dx + dy * dy) < 0.04;
    }

    function isOpenPalm(landmarks) {
      const tipIds = [8, 12, 16, 20];
      return tipIds.every(id => landmarks[id].y < landmarks[0].y);
    }

    const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5
    });

    hands.onResults(results => {
      const now = Date.now();

      if (results.multiHandLandmarks) {
        results.multiHandLandmarks.forEach((landmarks, i) => {
          const id = `hand${i}`;
          const tip = landmarks[8];
          const x = tip.x * canvas.width;
          const y = tip.y * canvas.height;

          // Clear only on open palm
          if (isOpenPalm(landmarks) && now - lastClearTime > 1500) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            lastPositions = {};
            lastClearTime = now;
            return;
          }

          // Pinch to cycle color
          if (isPinching(landmarks)) {
            if (!lastPinchTime[id] || now - lastPinchTime[id] > 1000) {
              colorIndex[id] = (colorIndex[id] || 0) + 1;
              if (colorIndex[id] >= roygbiv.length) colorIndex[id] = 0;
              colorByHand[id] = roygbiv[colorIndex[id]];
              lastPinchTime[id] = now;
            }
          }

          if (!colorByHand[id]) {
            colorIndex[id] = i % roygbiv.length;
            colorByHand[id] = roygbiv[colorIndex[id]];
          }

          if (!lastPositions[id]) lastPositions[id] = { x, y };

          ctx.strokeStyle = colorByHand[id];
          ctx.lineWidth = brushSize;
          ctx.beginPath();
          ctx.moveTo(lastPositions[id].x, lastPositions[id].y);
          ctx.lineTo(x, y);
          ctx.stroke();

          lastPositions[id] = { x, y };
        });
      }
    });

    const camera = new Camera(video, {
      onFrame: async () => {
        await hands.send({ image: video });
      },
      width: 640,
      height: 480
    });

    camera.start();
  </script>
</body>
</html>
